// This module builds a dependency graph that tracks variable events
// using unique IDs (generated by uuid). It records definitions, usages,
// transformations, exports, and imports.

import jscodeshift from "jscodeshift"; // ✅ Use jscodeshift for AST printing
import { v4 as uuidv4 } from "uuid";
import fs from "fs/promises";

// Interface defining the structure of tracked variables
interface VariableContext {
  file: string;
  varName: string;
  originalDefinition: string;
  usages: UsageEvent[];
  transformations: TransformationEvent[];
  exports: ExportEvent[];
  imports: ImportEvent[];
}

// Interfaces for different types of tracking events
interface UsageEvent {
  file: string;
  type: string;
  code: string;
  details?: Record<string, unknown>;
}

interface TransformationEvent extends UsageEvent {
}

interface ExportEvent {
  file: string;
  exportType: string;
  code: string;
  exportedAs: string;
}

interface ImportEvent {
  file: string;
  importType: string;
  code: string;
  importedAs: string;
}

export class ContextTracker {
  public variables: Record<string, VariableContext>;
  private j: jscodeshift.JSCodeshift; // ✅ Store reference to jscodeshift

  constructor() {
    // Map of uniqueId -> variable context data
    this.variables = {};
    this.j = jscodeshift.withParser("babel-ts"); // ✅ Use babel-ts parser
  }

  /**
   * Record a variable definition.
   * @param file - The file name where defined.
   * @param varName - The variable name.
   * @param definitionNode - The AST node for the definition.
   * @returns A unique ID for the variable.
   */
  addVariable(file: string, varName: string, definitionNode: any): string {
    const uniqueId = uuidv4();
    this.variables[uniqueId] = {
      file,
      varName,
      originalDefinition: this.j(definitionNode).toSource(), // ✅ Fix: Use jscodeshift
      usages: [],
      transformations: [],
      exports: [],
      imports: [],
    };
    return uniqueId;
  }

  /**
   * Track a usage of a variable.
   */
  trackUsage(
    uniqueId: string,
    file: string,
    usageNode: any,
    type: string,
    details: Record<string, unknown> = {}
  ): void {
    if (this.variables[uniqueId]) {
      this.variables[uniqueId].usages.push({
        file,
        type,
        code: this.j(usageNode).toSource(), // ✅ Fix: Use jscodeshift
        details,
      });
    }
  }

  /**
   * Track a transformation event (e.g., renaming or destructuring).
   */
  trackTransformation(
    uniqueId: string,
    file: string,
    transformationNode: any,
    type: string,
    details: Record<string, unknown> = {}
  ): void {
    if (this.variables[uniqueId]) {
      this.variables[uniqueId].transformations.push({
        file,
        type,
        code: this.j(transformationNode).toSource(), // ✅ Fix: Use jscodeshift
        details,
      });
    }
  }

  /**
   * Track an export event.
   */
  trackExport(
    uniqueId: string,
    file: string,
    exportNode: any,
    exportType: string,
    exportedAs: string
  ): void {
    if (this.variables[uniqueId]) {
      this.variables[uniqueId].exports.push({
        file,
        exportType,
        code: this.j(exportNode).toSource(), // ✅ Fix: Use jscodeshift
        exportedAs,
      });
    }
  }

  /**
   * Track an import event.
   */
  trackImport(
    uniqueId: string,
    file: string,
    importNode: any,
    importType: string,
    importedAs: string
  ): void {
    if (this.variables[uniqueId]) {
      this.variables[uniqueId].imports.push({
        file,
        importType,
        code: this.j(importNode).toSource(), // ✅ Fix: Use jscodeshift
        importedAs,
      });
    }
  }

  /**
   * Query a variable's context by its unique ID.
   */
  queryVariable(uniqueId: string): VariableContext | undefined {
    return this.variables[uniqueId];
  }

  /**
   * Save the dependency graph to a JSON file.
   */
  async saveGraphToFile(filePath: string): Promise<void> {
    await fs.writeFile(filePath, JSON.stringify(this.variables, null, 2), "utf-8");
  }

  /**
   * Load the dependency graph from a JSON file.
   */
  async loadGraphFromFile(filePath: string): Promise<void> {
    const data = await fs.readFile(filePath, "utf-8");
    this.variables = JSON.parse(data);
  }

  /**
   * Get the dependency graph.
   */
  getGraph(): Record<string, VariableContext> {
    return this.variables;
  }
}