// This module builds a dependency graph that tracks variable events
// using unique IDs (generated by uuid). It records definitions, usages,
// transformations, exports, and imports.

import recast from "recast";
import { v4 as uuidv4 } from "uuid";
import fs from "fs/promises";

// Interface defining the structure of tracked variables
interface VariableContext {
  file: string;
  varName: string;
  originalDefinition: string;
  usages: UsageEvent[];
  transformations: TransformationEvent[];
  exports: ExportEvent[];
  imports: ImportEvent[];
}

// Interfaces for different types of tracking events
interface UsageEvent {
  file: string;
  type: string;
  code: string;
  details?: Record<string, unknown>;
}

interface TransformationEvent extends UsageEvent {}

interface ExportEvent {
  file: string;
  exportType: string;
  code: string;
  exportedAs: string;
}

interface ImportEvent {
  file: string;
  importType: string;
  code: string;
  importedAs: string;
}

export class ContextTracker {
  private variables: Record<string, VariableContext>;

  constructor() {
    // Map of uniqueId -> variable context data
    this.variables = {};
  }

  /**
   * Record a variable definition.
   * @param file - The file name where defined.
   * @param varName - The variable name.
   * @param definitionNode - The AST node for the definition.
   * @returns A unique ID for the variable.
   */
  addVariable(file: string, varName: string, definitionNode: any): string {
    const uniqueId = uuidv4();
    this.variables[uniqueId] = {
      file,
      varName,
      originalDefinition: recast.print(definitionNode).code,
      usages: [],
      transformations: [],
      exports: [],
      imports: [],
    };
    return uniqueId;
  }

  /**
   * Track a usage of a variable.
   */
  trackUsage(
    uniqueId: string,
    file: string,
    usageNode: any,
    type: string,
    details: Record<string, unknown> = {}
  ): void {
    if (this.variables[uniqueId]) {
      this.variables[uniqueId].usages.push({
        file,
        type,
        code: recast.print(usageNode).code,
        details,
      });
    }
  }

  /**
   * Track a transformation event (e.g., renaming or destructuring).
   */
  trackTransformation(
    uniqueId: string,
    file: string,
    transformationNode: any,
    type: string,
    details: Record<string, unknown> = {}
  ): void {
    if (this.variables[uniqueId]) {
      this.variables[uniqueId].transformations.push({
        file,
        type,
        code: recast.print(transformationNode).code,
        details,
      });
    }
  }

  /**
   * Track an export event.
   */
  trackExport(
    uniqueId: string,
    file: string,
    exportNode: any,
    exportType: string,
    exportedAs: string
  ): void {
    if (this.variables[uniqueId]) {
      this.variables[uniqueId].exports.push({
        file,
        exportType,
        code: recast.print(exportNode).code,
        exportedAs
      });
    }
  }

  /**
   * Track an import event.
   */
  trackImport(
    uniqueId: string,
    file: string,
    importNode: any,
    importType: string,
    importedAs: string
  ): void {
    if (this.variables[uniqueId]) {
      this.variables[uniqueId].imports.push({
        file,
        importType,
        code: recast.print(importNode).code,
        importedAs
      });
    }
  }

  /**
   * Query a variable's context by its unique ID.
   */
  queryVariable(uniqueId: string): VariableContext | undefined {
    return this.variables[uniqueId];
  }

  /**
   * Save the dependency graph to a JSON file.
   */
  async saveGraphToFile(filePath: string): Promise<void> {
    await fs.writeFile(filePath, JSON.stringify(this.variables, null, 2), "utf-8");
  }

  /**
   * Load the dependency graph from a JSON file.
   */
  async loadGraphFromFile(filePath: string): Promise<void> {
    const data = await fs.readFile(filePath, "utf-8");
    this.variables = JSON.parse(data);
  }
}